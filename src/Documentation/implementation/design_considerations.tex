\chapter{Design Considerations}


\section{Assumptions and Dependencies}

\subsection{Processing performance, definition of real time}

This section is concerned with perfomance related issues, and the assumptions 
and dependencies that exist in the present system.

\subsubsection{Processing performance}

The existing system involves many components of a PC architecture:

\begin{itemize}
 \item{The microprocessor}
 \item{The graphic subsystem}
 \item{The I/O subsystem -- hard drive storage}
 \item{The I/O subsystem -- networking}
\end{itemize}

The configuration of the system will determine the actual load on these 
components and therefore the software might run on low--end machines, or it 
might require more advanced hardware.

If processor speed becomes an issue, adding subsystems with bus--mastered 
hardware and dedicated processors (SCSI--controllers, good 100MBit networking 
cards), might be a more favorable (and cheaper) solution than using a faster 
processor.

\subsubsection{Feasibility study}

We evaluated the system behavior and processor load caused by the 
'administrative' duties of the system, i.e., the communication between modules, 
under different scenarios (e.g., whether the modules reside on one or on 
seperate machines). In this study, all core modules not only transmitted all 
generated channels to the next core module (which is more than what the system 
would transmit in a real--world configuration), but also sent all channels as 
visualization data to the operator. However, neither was any data further 
processed in any module, nor was it visualized at the operator. 

The results in Figure \ref{feasibility_study} clearly show that this 
inter--module communication only has a small impact on processor load, and that 
this impact is relatively independent on system configuration.


\begin{figure}[ht]
 \centerline{\scalebox{0.66}{\includegraphics{figures/performance.eps}}}
 \caption{Overview over the results of the feasibility study}
 \label{feasibility_study}
\end{figure}


\subsubsection{Definition of real time}

In the most general terms, \textit{real time} means a reaction of a system to an 
event in an appropriate time period. However, the exact nature of this 
'appropriate time period' depends on the application; for instance, the 
constraint could be maximal response time, or average response time, or a system 
could only be called a real--time system, if it responds in no more than x ms in 
y percent of the time. In a virtual surgery environment, for example, one 
unexpected delay per year of 20ms could be fatal.

In a Brain Computer Interface environment, the system usually has to 
\begin{enumerate}
 \item{keep up with processing the EEG components over long time periods}
 \item{on average provide feedback in a timely manner (e.g., less than 100ms)}
\end{enumerate}

Being able to keeping up with processing directly is a function of the system's 
overall performance. System response time is also correlated system performance, 
but also influenced by the operating system (i.e., OS) -- simply because the 
communication involves the OS. As the feasibility study (figure 
\ref{feasibility_study}) shows, system latency in absence of signal processing 
or graphical feedback is very low (i.e., a few ms). This latency marks the 
minimal latency the system will be able to achieve.

Most OSs on the market are not \textit{real time} operating systems, that is, 
they don't guarantee a deterministic system response time. This includes the 
Microsoft Windows family of operating systems (except, Windows CE, under certain 
circumstances). This means that it is impossible to (at the application level) 
write code that operates under this definition. Time stamping data collection 
and feedback and storing these in fields in the state vector can be used to 
accomodate for differences in latency. In addition, for a BCI, it is appropriate 
to say that it is sufficient, if it provides feedback on average (e.g., 99.9 
percent of the time) in a timely manner. 


\subsection{Operating systems}

The system is programmed using Borland's C++ Builder application development 
environment. The target platform of this environment is Win32 code for Intel 
CPUs. Therefore, the possible operating systems are Windows 95/98, Windows 
NT4.0, or Windows 2000.

This system contains four processes with at least two threads each. Windows NT 
and its successors have built-in advanced priority based scheduling algorithms 
that are far superior than the simple context--switching based concepts in 
Windows 95 or 98. While neither the BCI2000 Project Outline nor this document 
excludes the use of any of these operating systems, it seems that described real 
time requirements can be met more easily under Windows NT and its successors.


\subsection{End-user characteristics}

\subsection{Possible and/or probable changes in functionality}

     
\section{General Constraints}

% Describe any global limitations or constraints that have a significant impact on 
%the design of the system's software (and describe the associated impact). Such 
%constraints may be imposed by any of the following (the list is not exhaustive): %

%     Hardware or software environment 
%     End-user environment 
%     Availability or volatility of resources 
%     Standards compliance 
%     Interoperability requirements 
%     Interface/protocol requirements 
%     Data repository and distribution requirements 
%     Security requirements (or other such regulations) 
%     Memory and other capacity limitations 
%     Performance requirements 
%     Network communications 
%     Verification and validation requirements (testing) 
%     Other means of addressing quality goals 
%     Other requirements described in the requirements specification 
     
 
\section{Goals and Guidelines}
\label{des_consid_goals}

\subsection{Module Independence}
\label{goals_module_independence}

One of the goals of the system design is to generate modules that are as 
independent of each other as possible. The BCI2000 Project Outline defines the 
communication protocols between the modules, but not the content of the 
transmitted EEG signals, control signals, or the state vector. Ideally, all 
modules are totally independent of each other. Even in a real--world situation, 
both the Data Acquisition and Operator modules can be independent of all other 
modules. However, signal processing might often depend on the feedback provided. 

In any case, the goal should be to minimize this interdepence. For example, 
different physiological phenomena (e.g., slow cortical potentials or the 
$\mu$--rhythm) might result in control signals with different distribution 
characteristics. As we pass a derived control signal from Signal Processing to 
the Application, we could either do post--processing, e.g., normalizing the 
signal and making it zero mean, in either the Signal Processing or Application 
module. Following the aforementioned idea, it seems favorable to do these 
manipulations in the signal processing module. In this case, the application 
does not need to account for different signal processing techniques.

%Describe any goals, guidelines, principles, or priorities which dominate or 
%embody the design of the system's software. Such goals might be: 

%     The KISS principle ("Keep it simple stupid!") 
%     Emphasis on speed versus memory use 
%     working, looking, or "feeling" like an existing product 

%For each such goal or guideline, unless it is implicitly obvious, describe the 
%reason for its desirability. Feel free to state and describe each goal in its 
%own subsubsection if you wish. 


\section{Development Methods}

%Briefly describe the method or approach used for this software design. If one or 
%more formal/published methods were adopted or adapted, then include a reference 
%to a more detailed description of these methods. If several methods were 
%seriously considered, then each such method should be mentioned, along with a 
%brief explanation of why all or part of it was used or not used.

