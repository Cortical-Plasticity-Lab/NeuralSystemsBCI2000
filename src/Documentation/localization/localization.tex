\documentclass[12pt,a4paper]{article}
%\documentclass[12pt,a4paper,fleqn]{article}
%\usepackage{ngerman}
%\usepackage{bibgerm}
\usepackage{graphicx}
\usepackage{epsfig}
%\sloppy
%\flushbottom

%\pagestyle{empty}

\title{BCI 2000 Localization}
%\date{}
\author{J\"{u}rgen Mellinger}

\begin{document}
\maketitle
\tableofcontents

\pagebreak
\section{Introduction}

As BCI2000 modules are being used in various countries, there emerges some need
to adapt user interface elements to regional customs. Most notably, text that
gives information to the subject requires translation into the subject's native
language, as often a knowledge of English cannot be assumed, and if so, reading
text in a foreign language is a distracting factor that makes the already demanding
task of operating a BCI even more difficult.

This document explains the approach taken to manage localized (translated) user interface
strings in BCI2000 application modules, trying to meet the following goals:

\begin{itemize}
\item\textbf{Flexibility:}
For the end user (operator), it should be possible to add translations into a language that is not provided inside an
application module, and to modify translations he does not feel to be appropriate.
This should be achievable without making changes to the source code and recompiling the application module.
\item\textbf{Separability:}
For the user, switching languages should be done at a central place, i.e. by changing a single parameter.
For the programmer,
adding localization capabilities to existing modules should
be possible with minimal changes to existing code.
When writing new application modules, there should be no need to consider localization issues in advance.
\item\textbf{Documentation:}
Documenting and providing a collection of existing translations into various languages should be possible inside a module's source code.
\end{itemize}


\section{Strategies}

For a number of text values that have always been set from parameters (such as the Speller module's \texttt{Goal} parameter that holds the text the user is told to spell in copy spelling mode), localization is not an issue because the user may just change the value as it seems appropriate.

The remaining text items, according to the way they are specified, fall into two categories:
\begin{enumerate}
\item
C string literals in \texttt{*.cpp} source files, and
\item
text fields in GUI resource files (such as Borland \texttt{*.dfm} files).
\end{enumerate}

For both categories, translations are kept in a single matrix type parameter that uses string labels,
i.e. row and column titles.
Each column title represents the native English version of a text; row titles represent
languages for which translations exist. The user chooses amongst languages by specifying
the desired language in a second parameter; the BCI2000 framework will then use this table to look up a text's translation, matching the text itself against column labels, and 
the target language against row labels. If no match is found, it will leave the text unchanged.

For string literals in \texttt{*.cpp} files, the strategy is to simply put a function layer around the string, i.e. to send it through a function that checks for a translation
and exchanges the text if there is a match. When introducing localizability into existing code, this implies only a very small amount of changes compared to, e.g., introducing
a separate parameter for each string. In the former case, one needs only wrap the string literal into a function call in-place; in the latter case, one would have to add a parameter line to a possibly remote filter class constructor, read that parameter from inside that filter's \texttt{Initialize()} call, and put it into the object that actually holds the string which might require introduction of additional accessor functions.

For strings specified in GUI resource files, the strategy is to supply a function that, very generally, examines string properties of GUI objects, replacing them with their localized versions if applicable.
This function needs to be called explicitly from inside the \texttt{Initialize()} function of the \texttt{GenericFilter} descendant that determines the GUI object's behavior (in most cases, this is the application module's \texttt{TTask} class).

\section{Implementation}

The implementation is centered around a \texttt{Localization} class declared in \texttt{Application/shared/Localization.h}.

\subsection{Interface to the operator user}

The \texttt{Localization} class adds two parameters to the system that govern its localization
behavior: 
\begin{itemize}
\item
\texttt{Language} defines the language to translate strings
into; if its value matches one of the \texttt{LocalizedStrings} row
labels, translations will be taken from that row; otherwise,
strings will not be translated.
A value of \texttt{Default} results in all strings keeping their original values.
\item
\texttt{LocalizedStrings} defines string translations. Strings that
don't appear as a column label will not be translated.
Also, strings with an empty translation entry in \texttt{LocalizedStrings}
will not be translated.
\end{itemize}

\subsection{Interface to the programmer}

The \texttt{LocalizedStrings} parameter is empty by default.
Although a user may add translations into desired languages to the empty matrix by hand -- using the operator module's matrix editor --,
translations will preferably be provided in a filter constructor by listing them as in the following example:
\begin{verbatim}
#include "Localization.h"
...
TTask::TTask()
{
  ...
  LANGUAGES "Italian",
            "French",
  BEGIN_LOCALIZED_STRINGS
   "Yes",
            "Si",
            "Oui",
   "No",
            "No",
            "Non",
  END_LOCALIZED_STRINGS
  ...
}
\end{verbatim}

If the \texttt{LocalizedStrings} matrix was empty before the \texttt{TTask} constructor gets called, it will have these entries after execution of the constructor:

\begin{center}
\begin{tabular}[t]{l|ll}
          & Yes   & No  \\ \hline
  Italian & Si    & No  \\
  French  & Oui   & Non \\
\end{tabular}
\end{center}

There may be any number of translation tables inside filter constructors, with their
entries being added to the existing ones, or overriding entries that already exist.

Once entered,
the translations contained in \texttt{LocalizedStrings} are applied via two mechanisms:
\begin{itemize}
\item
The function \texttt{LocalizableString()} takes a string as an argument and returns
the appropriate entry from \texttt{LocalizedStrings}, or the unmodified string if no entry
can be found.
E.g., instead of
\begin{verbatim}
TellUser( "Well done!" );
\end{verbatim}
one would write
\begin{verbatim}
#include "Localization.h"
...
TellUser( LocalizableString( "Well done!" ) );
\end{verbatim}

to have a translation for ``Well done!'' looked up in \texttt{LocalizedStrings}.
\item
The function \texttt{ApplyLocalizations()} takes a pointer to a GUI object (usually
a VCL \texttt{TForm*}) and translates all localizable text contained within it.
This function must be called during \texttt{GenericFilter:: Initialize} for each GUI
object generated from a resource file.
\end{itemize}

\subsection{Further implementation details}
\begin{itemize}
\item
You should not use \texttt{LocalizableString()} on string constants used
before the first call to \texttt{GenericFilter::Initialize()} or for
initializing static or global objects of any kind because localization
information used will not be available at global initialization time, and local static variables, once initialized, will not be updated appropriately.
\item
Language names are case-insensitive. You may use any string for a language name but as a convention we suggest
its most common English name, as in
\texttt{Italian, Dutch, French, German},
with international country abbreviations as optional regional
qualifiers as in
\texttt{EnglishUS, EnglishGB, GermanA, GermanCH}
if necessary.
\item
Encoding of non-ASCII characters follows the UTF8
convention. To ensure platform independent readability of source
code files, there are macros that define HTML character names
to their UTF8 encoded strings. This allows to write

\texttt{"Sm" oslash "rrebr" oslash "d"}

for ``Sm\o{}rrebr\o{}d'' (cf.\ table~\ref{tab:HTMLchars}).

\end{itemize}

\begin{table}
\centering
\begin{tabular}[t]{|l|c||l|c||l|c||l|c|} \hline
\texttt{Agrave}   & \`A   &
\texttt{Aacute}   & \'A   &
\texttt{Acirc}    & \^A   &
\texttt{Atilde}   & \~A   \\
\texttt{Auml}     & \"{A} &
\texttt{Aring}    & \AA   &
\texttt{AElig}    & \AE   &
\texttt{Ccedil}   & \c{C} \\
\texttt{Egrave}   & \`E   &
\texttt{Eacute}   & \'E   &
\texttt{Ecirc}    & \^E   &
\texttt{Euml}     & \"{E} \\
\texttt{Igrave}   & \`I   &
\texttt{Iacute}   & \'I   &
\texttt{Icirc}    & \^I   &
\texttt{Iuml}     & \"{I} \\
\texttt{Ntilde}   & \~N   &
\texttt{Ograve}   & \`O   &
\texttt{Oacute}   & \'O   &
\texttt{Ocirc}    & \^O   \\
\texttt{Otilde}   & \~O   &
\texttt{Ouml}     & \"{O} &
\texttt{Oslash}   & \O    &
\texttt{Ugrave}   & \`U   \\
\texttt{Uacute}   & \'U   &
\texttt{Ucirc}    & \^U   &
\texttt{Uuml}     & \"{U} &
\texttt{Yacute}   & \'Y   \\
\texttt{szlig}    & \ss   &
\texttt{agrave}   & \`a   &
\texttt{aacute}   & \'a   &
\texttt{acirc}    & \^a   \\
\texttt{atilde}   & \~a   &
\texttt{auml}     & \"{a} &
\texttt{aring}    & \aa   &
\texttt{aelig}    & \ae   \\
\texttt{ccedil}   & \c{c} &
\texttt{egrave}   & \`e   &
\texttt{eacute}   & \'e   &
\texttt{ecirc}    & \^e   \\
\texttt{euml}     & \"{e} &
\texttt{igrave}   & \`i   &
\texttt{iacute}   & \'i   &
\texttt{icirc}    & \^i   \\
\texttt{iuml}     & \"{i} &
\texttt{ntilde}   & \~n   &
\texttt{ograve}   & \`o   &
\texttt{oacute}   & \'o   \\
\texttt{ocirc}    & \^o   &
\texttt{otilde}   & \~o   &
\texttt{ouml}     & \"{o} &
\texttt{oslash}   & \o    \\
\texttt{ugrave}   & \`u   &
\texttt{uacute}   & \'u   &
\texttt{ucirc}    & \^u   &
\texttt{uuml}     & \"{u} \\
\texttt{yacute}   & \'y   &
\texttt{yuml}     & \"{y} &&&&\\ \hline
\end{tabular}
\caption{HTML names for international characters}
\label{tab:HTMLchars}
\end{table}

\end{document}
