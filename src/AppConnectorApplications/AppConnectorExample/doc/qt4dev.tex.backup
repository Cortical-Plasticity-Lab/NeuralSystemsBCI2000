\section{Qt4 Development}

\subsection{Signals/Slots}Making the move to Qt4 can be a little confusing at first if you are used to how Borland or Microsoft handle things in C++, or Visual Basic/C\#. In Borland C++ and MSVB or C\#, GUI events directly trigger a callback function, which executes code and returns (i.e. you press a button, the code in the button callback is executed). Qt4 handles things a little differently. Qt4 implements what is called a SIGNAL/SLOT system, in which an object (button, list, any GUI element) emits a SIGNAL when a particular event occurs. This SIGNAL is connected to the SLOT of another object. All Qt4 objects have a number of predefined SIGNALS and SLOTS for the standard actions associated with such an object; for example, the most-commonly used SIGNAL for a button object is probably clicked(). To connect a SIGNAL and SLOT, use the \texttt{connect} command. Here is an example using two Qt objects:\\\\
\texttt{QPushButton *button(``Quit'');
\\QApplication *app;
\\connect(button, SIGNAL(clicked()), app, SLOT(quit()));}\\\\

In this example, a button pointer with the caption ``Quit'' is created, and the Qt4 Application is created. The button clicked() event is then tied to the quit() SLOT function for that app. So when the button is clicked, it calls the quit() function, which closes the window and application. As a result, many of the common tasks for an object are already defined, and you do not need to code them. An entire simple application might look like: \\

\begin{verbatim}
#include <QApplication>
#include <QPushbutton>

int main(int argc, char *argv[])
{
   QApplication app(argc, argv);
   QPushButton button(``Quit'');
   connect(&button, SIGNAL(clicked()), &app, SLOT(quit()));
   button.show();
   return app.exec();
}
\end{verbatim}

\subsection{Extending Widgets}
Even though there are many useful predefined SLOTS, you will eventually need to create your own functions to handle events. This is done through subclassing. In Qt (and C++), it is important to divide components into their own classes. This includes the GUI. Therefore, when creating a form, you will want to create a class that inherits from a Qt object, most likely either a QWidget or QMainApplication. (QWidget is basically a completely blank form, while QMainApplication comes with a menu bar, a status bar, and other common features of an application). Importantly, inheriting from a QWidget (or QObject if it is not necessarily a user interface) allows us to create our own SIGNALS and SLOTS. So, here is a simple example class that inherits from QWidget, contains a button, and creates a custom SLOT.\\

\begin{verbatim}
//mainUI.h-------------

//include the components necessary to create a Qt GUI
#include <QtGui>

class QPushButton;

//create our form's class, inheriting from the QWidget class
class mainUI : public QWidget
{
	//the Q_OBJECT macro is necessary for creating SIGNALS/SLOTS, and must
	//be declared at the start of the class
	Q_OBJECT

	//SLOTS are created using the private slots: declaration in the class definition
	//slot functions are declared and implemented just as normal class methods
	private slots:
		void customButtonCallback();

	private:
		//our button
		QPushButton *button;
		//this layout arranges the object vertically, see Qt docs for more
		QVBoxLayout *mainLayout;

	public:
		//our class constructor
		mainUI();
};

//mainUI.cpp-------------------------------
//here is our implementation
mainUI::main()
{
	button = new QPushButton("Push Me");
	mainLayout = new QVBoxLayout;

	//connect our button signal to our custom slot
	//since it is defined within this object, use the this keyword for the SLOT target
	connect(button, SIGNAL(clicked()), this, SLOT(customButtonCallback()));

	//setup the layout
	mainLayout->addWidget(button);
	setLayout(mainLayout);
}

void mainUI::customButtonCallback()
{
	//this function is called whenever the button is pressed
	//do what you want here
}

//main.cpp---------------------------------
//this file starts the app
#include <QApplication>
#include "mainUI.h"

int main(int argc, char *argv[])
{
	//create the QT application
	QApplication app(argc, argv);
	
	//create our custom widget class
	mainUI mainWin;
	//show it
	mainWin.show();
	//execute the program
	return app.exec();
}
\end{verbatim}


\subsection{Creating an AppConnector Program}
To start creating an AppConnector program, a some BCI2000 source files must be included: the TCPStream.cpp and TCPStream.h files. These contain the class definitions for the UDP socket and stream objects, which are used to read and write states with BCI2000. Create these objects as follows:\\

\begin{verbatim}
#include "TCPStream.h"

...

receiving_udpsocket recSocket;
tcpstream recConnection;
sending_udpsocket sendSocket;
tcpstream sendConnection;
\end{verbatim}

To setup the connection, you first open the socket connection to an IP address and port using a string:\\\\
\texttt{recSocket.open(``localhost:20320'');}\\

The stream is initialized using the socket object created:\\\\
\texttt{recConnection.open(recSocket);}\\\\

Check if the connection is open:\\

\begin{verbatim}
if (!recConnection.is_open())
    //some error message...
\end{verbatim}

The sending connection is setup the same way:

\begin{verbatim}
sendSocket.open("localhost:20321");
sendConnection.open(sendSocket);
if (!sendConnection.is_open())
    //error...
\end{verbatim}

Note that you will not likely want to hard-code the IP and port. Providing a text box for these options in your program and using the text field to set the address is more functional.\\
To setup BCI2000 to work with your program, in the Config menu, go to the ConnectorFilter tab. Under ConnectorOutputAddress, use the IP and Port used in the \textbf{Receving} address in the external program. So, if the receiving port and IP in the AppConnector program are \texttt{localhost:20320}, then the ConnectorOutputAddress in BCI2000 should be \texttt{localhost:20320}. Similarly, if the sending port and ip in the AppConnector program are \texttt{localhost:20321}, then the ConnectorInputAddress in the BCI2000 config should be \texttt{localhost:20321}.\\
Since a network protocol is used for communication, the AppConnector program does not have to be on the same machine that is running BCI2000. For example, your desktop could be running BCI2000 on Windows, and your laptop running linux can run the AppConnector and connect to BCI2000. To do this, use the actual machine IP addresses for each computer. For example, if the PC with BCI2000 has an IP of 192.168.0.100 and the laptop has an IP of 192.168.0.101, then on the BCI2000 PC, the ConnectorOutputAddress should be set to 192.168.0.101:20320, the ConnectorInputAddress to 192.168.0.100:20321; on the laptop, the sending address should be 192.168.0.100:20321, and the receiving address should be 192.168.0.101:20320 (Table \ref{tab:connect}) 

\begin{table}
 \begin{center}
% use packages: array
\begin{tabular}{l | l |l}
\hline
 & BCI2000 & AppConnector \\ 
\hline
IP Address & 192.168.0.100 & 192.168.0.101 \\ 
ConnectorOutputAddress & 192.168.0.101:20230 & 192.168.0.100:20231 \\ 
ConnectorInputAddress & 192.168.0.100:20231 & 192.168.0.101:20230\\
\hline
\end{tabular}

\end{center}

\caption{Connections}
\label{tab:connect}
\end{table} 

\pagebreak
Once your connection is setup, using the tcpstream objects is simple. A function that reads data from the stream and stores the states and associated values in a map might look like this:

\begin{verbatim}
 bool readData(map<string, float> &map, tcpstream &recConnection)
 {
    int count = 0;

    //while there is data available in the buffer, read it
    while (recConnection.rdbuf()->in_avail())
    {
        string name;
        float value;
    	
        //read the data using the stream format (i.e. >> operator)
        recConnection >> name >> value;
        recConnection.ignore();

        //check if there is some kind of error, and ignore it
        if (!recConnection)
            recConnection.ignore();

        map[name] = value;
        count++;
    }

    //if we read and recorded data, return true
    if (count > 0)
        return true;
    else
        return false;
 }
\end{verbatim}

After this function is called, the map contains the names and values of all of the states. To access the state value, use its name as the input to the [] operator, like:\\
\texttt{float value = map[``Feedback''];}\\

Writing data is even simpler using the stream format. Here is a short example:\\

\begin{verbatim}
 string name = "Feedback";
 short value = 0;
 sendConnection << name << ' ' << value << endl;
\end{verbatim}

That's it! BCI2000 handles all of the checks for whether the state exists and if it was a valid value.\\
To finish, here is a simple example that reads a state value, modifies it, and sends it back to BCI2000:

\begin{verbatim}
 #include <map>
 #include <string>
 #include "TCPStream.h"

 using namespace std;
 int main()
 {
    receiving_udpsocket recSocket;
    tcpstream recConnection;
    sending_udpsocket sendSocket;
    tcpstream sendConnection;

    //open the sockets and streams (error checking as been removed)
    sendSocket.open("localhost:20321");
    sendConnection.open(sendSocket);

    recSocket.open("localhost:20320");
    recConnection.open(sendSocket);

    map<string, float> states;
    while (true)
    {
        //try to read the states into the map
        if (readData(&states, &recConnection))
        {
            float value = states["CursorPosX"];
            //change the value by 100, then write it to the output
            value += 100;
            sendConnection << "CursorPosX " << value << endl;

        }
    }
 }
\end{verbatim}








