<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>BCPy2000: Timing</title>
<link type="text/css" rel="stylesheet" href="styles/gears/style.css" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
<div class="header"><span class="gotobar bar"><a class="local" href="About.html">About</a> <a class="local" href="Download.html">Download</a> <a class="local" href="Structure.html">Structure</a> <a class="local" href="Demo.html">Demo</a> <a class="local" href="Hooks.html">Hooks</a> <a class="local" href="API.html">API</a> <a class="local" href="Support.html">Support</a> <a class="local" href="Credits.html">Credits</a> <a class="local" href="License.html">License</a> </span><h1>Timing</h1></div><div class="content"><p>Really, there is no substitute for having a physical timing signal recorded in the data stream, such as a TTL signal from the parallel port or, safer still, a physical recording of the light or sound produced by a stimulus. However, if the hardware to do this is unavailable, the "event offset" mechanism may offer some form of fallback.</p><p>The <a class="local" href="BciGenericApplication.html">BciGenericApplication</a> superclass defines the <code>EventOffset</code> state, which is zero most of the time, but which is set to a non-zero value for the duration of one packet whenever a <a class="local canonical" title="Phase_Machine" href="Phase_Machine.html">phase transition</a> occurs. Its value reflects the offset, in samples, between the time that the signal was acquired, and the time at which <code>self.</code><a class="local anchor" href="BciGenericApplication.html#BciGenericApplication-Transition">Transition</a> was called. Estimated transition points are obtained by: </p><ol><li>finding the time-samples at which the <code>EventOffset</code> state changes from zero to a non-zero value;</li><li>stepping forward by a number of samples equal to the value to which <code>EventOffset</code> is changing, minus <code>2**(bits-1)</code>, where <code>bits</code> is the number of bits allocated to the state variable (currently 10).</li></ol><p>We have performed tests in which transitions occur at random intervals, each accompanied by a parallel-port marker and an annoying sound (with a sudden attack) whose physical waveform is recorded (albeit undersampled) by an EEG amp. On our machines, using packets of duration 40 msec and sampling at 500Hz, we found the following: </p><ul><li>Parallel-port markers issued immediately at the transitions could be localized with a standard error of +/- 1 msec or less.</li><li>Parallel-port markers locked to <a class="local" href="WavTools.html">WavTools</a><code>.player</code> sounds (via the <code>set_preplay_hook</code> method) were more like +/- 2 msec.</li><li>Since the previous release (1.0) a bugfix in <a class="local" href="WavTools.html">WavTools</a><code>.PyAudioInterface</code> has meant that PyAudio-implemented sounds are just as precisely localizable as those issued by the DirectSound binary---the latter will therefore not be included in the release after all. Sounds could be found with +/- 3 msec precision using <code>EventOffset</code>. Latency between parallel port marker and sound is around 30 msec, with a standard deviation of +/- 2 msec.</li><li>The event-offset mechanism still seems to have biases that we're trying to iron out (see <a class="local canonical" title="Known_Issues" href="Known_Issues.html">known issues</a>) but these do not cause a problem for automatic classification methods: precision matters more than accuracy.</li><li>Relying purely on the moments at which state variables can change their value, i.e. the packet boundaries, would typically get you +/- 14 msec at a packet length of 40 msec. Note that the BCI2000 C++ framework now has, as of roughly August 2008, a mechanism for changing state variable values on a sub-packet basis, from the instant that a particular C++ call is made. We have not yet figured out a way to take advantage of this given that our timing information comes from Python embedded <em>within</em> the C++ rather than vice versa.</li></ul><p>The same experiment is also used to test <a class="local canonical" title="Video_timing" href="Video_timing.html">video timing</a>.</p></div><div class="footer"><hr /> <span class="gotobar bar"><a class="local" href="About.html">About</a> <a class="local" href="Download.html">Download</a> <a class="local" href="Structure.html">Structure</a> <a class="local" href="Demo.html">Demo</a> <a class="local" href="Hooks.html">Hooks</a> <a class="local" href="API.html">API</a> <a class="local" href="Support.html">Support</a> <a class="local" href="Credits.html">Credits</a> <a class="local" href="License.html">License</a> </span> <span class="edit"></span> <span class="time"><span class="time"><br /> Last edited 2009-03-16 14:24 UTC by <a class="author" title="from localhost" href="jez.html">jez</a> <a class="diff">(diff)</a></span></span></div></body></html>