<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>BCPy2000: Video_timing</title>
<link type="text/css" rel="stylesheet" href="styles/gears/style.css" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body>
<div class="header"><span class="gotobar bar"><a class="local" href="Home.html">Home</a> <a class="local" href="About.html">About</a> <a class="local" href="Download.html">Download</a> <a class="local" href="Structure.html">Structure</a> <a class="local" href="Demo.html">Demo</a> <a class="local" href="Hooks.html">Hooks</a> <a class="local" href="API.html">API</a> <a class="local" href="Contact.html">Contact</a> <a class="local" href="Credits.html">Credits</a> <a class="local" href="License.html">License</a> </span><h1>Video timing</h1></div><div class="content"><p>The same measurement experiment we use for assessing <a class="local canonical" title="Timing" href="Timing.html">event timing</a> also alternates the colour of a small patch between black and white on every frame, and measures the frame timing in milliseconds. Dropped frames are visible as a flash, and usually stand out in the timing logs.</p><p>So far we have been unable to eliminate entirely the phenomenon of occasional dropped frames. These occur particularly at phase transitions, although it is still not clear exactly why. It may be a function of the fact that we are running VisionEgg in one of a number of parallel threads (Python is notorious for its "global interpreter lock" which makes true multi-threading impossible). So we might have to wait for all our <a class="local canonical" title="Python_Packages" href="Python_Packages.html">dependencies</a> to catch up to Python 2.6+, where multi-process support is available as an alternative to multi-threading, before this can be solved completely.</p><p>Current mysteries are: </p><ul><li>The time taken for <code>VisionEgg.Core.swap_buffers</code> and <code>VisionEgg.GL.glFlush</code> seems to depend on the size of the window being painted, which is not how double-buffering should behave in theory.</li><li>Issuing a call to <code>self.change_phase()</code>, thereby forcing <code>self._phase_machine</code> to call <code>self.Transition()</code>, tends to cause a skip, whereas just calling <code>self.Transition()</code> directly (and hence performing all the same stimulus operations) does not. What's the difference? Just the <code>time.sleep()</code> call in <code>_phase_machine</code>?</li></ul></div><div class="footer"><hr /> <span class="gotobar bar"><a class="local" href="Home.html">Home</a> <a class="local" href="About.html">About</a> <a class="local" href="Download.html">Download</a> <a class="local" href="Structure.html">Structure</a> <a class="local" href="Demo.html">Demo</a> <a class="local" href="Hooks.html">Hooks</a> <a class="local" href="API.html">API</a> <a class="local" href="Contact.html">Contact</a> <a class="local" href="Credits.html">Credits</a> <a class="local" href="License.html">License</a> </span> <span class="edit"></span> <span class="time"><span class="time"><br /> Last edited 2009-03-17 00:50 UTC by <a class="author" title="from localhost" href="jez.html">jez</a> <a class="diff">(diff)</a></span></span></div></body></html>